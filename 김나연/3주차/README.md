# **6강**

## merge?

Spring Data JPA의 `save()` 메소드는 식별자의 존재 여부에 따라 내부적으로 `persist()`나 `merge()`를 조건적으로 호출. 식별자가 없는 경우 `persist()`를 호출하여 객체를 새로 저장하고, 식별자가 있는 경우에는 `merge()`를 호출하여 객체의 상태를 갱신.

`merge()`가 전달된 객체를 복사하여 새로운 객체를 반환하는 과정에서 기존 객체의 변경을 반영하기 위해 사용되는데, 이 과정에서 의도치 않은 일부 데이터 손실이 발생할 수 있음.

# **7강**

## 생성 메서드?

```java
//==생성 메서드==//
public static Order createOrder(Member member, Delivery delivery,
  OrderItem... orderItems) {
         Order order = new Order();
         order.setMember(member);
         order.setDelivery(delivery);
         for (OrderItem orderItem : orderItems) {
             order.addOrderItem(orderItem);
         }
         order.setStatus(OrderStatus.ORDER);
         order.setOrderDate(LocalDateTime.now());
         return order;
}
```

왜 생성자 대신에 생성 메서드를 쓸까?

정적 팩토리 메서드(static factory method): 객체를 생성하는 메소드를 만들고, `static`으로 선언하는 기법

장점

1. 이름이 있으므로 생성자에 비해 가독성이 좋다.
2. 호출할 때마다 새로운 객체를 생성할 필요가 없다.
3. 하위 자료형 객체를 반환할 수 있다.
4. 형인자 자료형(parameterized type) 객체를 만들 때 편하다.

형인자 자료형? (List\<String\> 같은 거)

## cascade 옵션? 이것의 범위는 어디까지인지

JPA에서 엔티티 간의 연관 관계를 정의할 때 사용

- `PERSIST`: 부모 엔티티가 저장될 때, 자식 엔티티도 함께 저장, 부모 엔티티를 영속성 컨텍스트에 추가할 때 자식 엔티티도 같이 추가
- `MERGE`: 부모 엔티티가 병합될 때, 자식 엔티티도 함께 병합, 부모 엔티티의 상태가 변경되면 자식 엔티티의 상태도 같이 변경
- `REMOVE`: 부모 엔티티가 삭제될 때, 자식 엔티티도 함께 삭제, 부모 엔티티를 영속성 컨텍스트에서 제거할 때 자식 엔티티도 같이 제거
- `REFRESH`: 부모 엔티티를 새로 고칠 때, 자식 엔티티도 함께 새로 고침
- `DETACH`: 부모 엔티티가 영속성 컨텍스트에서 분리될 때, 자식 엔티티도 함께 분리
- `ALL`: 위의 모든 CascadeType 옵션을 적용

→부모 엔티티와 자식 엔티티가 밀접한 관계에 있고 항상 서로 동시에 존재할 수 밖에 없는 개념이라면 두 엔티티를 동시에 관리할 수 있으므로 간편함

→그러나, 각 엔티티가 독립적으로 존재해야 하는 경우에도 무분별하게 사용할 경우 무결성(데이터의 Lifecycle 동안 모든 데이터가 얼마나 완전하고, 일관되며, 정확한지를 나타내는 정도)의 문제가 생김

강의에서는 완전히 개인 소유하는 엔티티일 때만 사용하고 웬만해선 지양하라고 명시.

ex) 게시판과 첨부파일, 첨부파일은 게시판 엔티티만 참조하므로 개인소유.

## 도메인 모델 패턴 vs 트렌젝션 스크립트 패턴

### 도메인 모델 패턴

- 도메인이 비즈니스 로직의 주도권을 가지고 개발하는 것을 도메인 주도 설계
- 서비스의 많은 로직이 엔티티로 이동하고, 서비스는 엔티티를 호출하는 정도의 얇은 비즈니스 로직을 가지게 됨.
- 코드의 응집도를 높여 중복을 방지하고 재사용성을 높이는 부분에 장점이 크다
- 엔티티를 객체로 사용

### 트렌젝션 스크립트 패턴

- 엔티티는 단순히 getter, setter만 제공하고, 서비스에 비즈니스 로직이 모두 있음
- 서비스 로직이 커지고, 엔티티는 단순히 데이터를 전달하는 역할만 담당
- 엔티티를 자료 구조로 사용

어떤게 더 좋은 패턴일까.. → 잘몰겠다

## criteria builder가 무엇일까..

### Criteria

- JPQL 의 작성을 도와주는 빌더 클래스
- 문자열로 JPQL 을 작성하면 런타임이 되어야 문법 오류를 알 수 있지만 Criteria 는 자바 코드 기반이기 때문에 안전하게 JPQL 을 작성할 수 있음
- CriteriaBuilder 인스턴스를 생성한 후 사용

(근데 실무에서 잘 안쓴다고 강의에 나옴. 너무 코드가 복잡..)

## 동적 쿼리를 어떻게 해결하는지?(ex. 검색)

1. JPQL로 처리
2. JPA Criteria로 처리
3. Querydsl로 처리

다음 시간에 계속..

### 추가로 할 것

도메인과 엔티티에 대해 더 알아볼 것

추천한 영상도 볼것
