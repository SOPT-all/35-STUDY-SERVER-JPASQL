## 섹션 8.

### ✔️ 타임리프(Thymeleaf)

타임리프(Thymeleaf)는 Java 기반 템플릿 엔진으로, Spring Framework와 주로 함께 사용 

HTML, XML, 그리고 텍스트 파일을 처리하고 렌더링하는 데 사용되며, 서버 사이드에서 동적으로 웹 페이지를 생성할 때 유용

**특징:**

- **HTML 친화적**: 타임리프는 HTML 태그 속성을 확장하는 방식으로 동작하므로, **순수 HTML 코드와의 호환성이 뛰어남**.
- **템플릿 엔진**: 동적 데이터를 HTML에 삽입해 뷰를 생성.
- **WYSIWYG 지원**: Thymeleaf는 템플릿이 브라우저에서도 미리 보이는 기능을 지원.
- **Spring과의 통합**: Spring Boot와 완벽하게 호환되며, `Model` 객체를 통해 데이터를 쉽게 전달할 수 있음.

### ✔️ **Include-Style Layout vs Hierarchical-Style Layout**

- **Include-style layout**: 레이아웃을 **다양한 HTML 파일의 조합**으로 구성하는 방식, 각 섹션(헤더, 푸터, 네비게이션 바 등)을 별도의 파일로 작성하고 필요할 때 가져와서 사용
- **Hierarchical-style layout**: **부모-자식 구조로 레이아웃을 구성**하는 방식, 주로 부모 레이아웃(템플릿 파일)과 자식 레이아웃(상세 페이지)을 구분해서 사용

| 스타일 | 개념 | 사용 방식 | 주로 쓰이는 태그 |
| --- | --- | --- | --- |
| **Include-style** | 파일을 **조합**해서 포함시킴 | 헤더, 푸터 등을 파일로 나눠서 가져옴 | `th:insert`, `th:replace` |
| **Hierarchical-style** | 부모-자식 **상속** 구조로 레이아웃 정의 | 부모 레이아웃에 자식 내용을 주입 | `th:replace`, `th:fragment` |

### ✔️ Spring Boot DevTools

- 자동 재시작 기능: 코드 변경 사항을 감지해서 애플리케이션을 자동으로 재시작함.
- LiveReload 지원: 변경된 내용을 브라우저에서 자동으로 새로고침해 보여줌.
- 캐시 무효화: 템플릿 캐시, 정적 리소스 캐시를 비활성화해 바로 반영되게 함.

### ✔️ **`restarted Main`의 의미**

Spring Boot DevTools가 코드 변경을 감지하면 애플리케이션을 재시작(restart)하게 된다. 하지만 완전히 JVM을 종료하고 다시 시작하는 게 아니라, 기존의 실행된 애플리케이션을 빠르게 재시작한다.

Spring Boot는 두 개의 ClassLoader를 사용해 변경사항을 감지하고, `restarted Main`은 바로 이 "빠른 재시작" 과정에서 나타나는 메시지.

1. **Base ClassLoader**: 변경되지 않는 라이브러리, 의존성 파일을 로드. (이 부분은 재시작하지 않음)
2. **Restart ClassLoader**: 프로젝트의 클래스와 리소스를 로드. (여기에 변경이 감지되면 **재시작**됨)

### ✔️ 부트스트랩(Bootstrap)

웹사이트를 빠르고 쉽게 만들기 위한 프론트엔드 프레임워크

- **반응형 디자인:** 다양한 디바이스(PC, 태블릿, 모바일)에서 화면 크기에 맞게 레이아웃이 자동으로 조정
- **미리 정의된 UI 컴포넌트:** 버튼, 네비게이션 바, 카드, 폼, 모달 등 다양한 UI 요소를 쉽게 사용 가능

1. `@NotEmpty` : Bean Validation에서 제공되는 어노테이션으로, 값이 비어있지 않은지 검증할 때 사용

```java
@NotEmpty(message = "이름은 비어있을 수 없습니다.")
private String name;
```

2. `@Valid` 어노테이션 : Bean Validation에서 제공하는 어노테이션으로, 객체에 대해 재귀적으로 검증을 수행할 때 사용

✅ 실무에서 Entity는 핵심 비즈니스 로직만, 화면을 위한 로직(api)에는 폼 객체나 DTO를 사용해줘야 한다. Entity는 최대한 순수하게!

### ✔️ 변경감지와 병합 ⭐️중요⭐️

**▪️ 준영속 엔티티**

- JPA의 엔티티 생명주기에서 영속 상태에서 분리된 엔티티, 영속성 컨텍스트에 더 이상 관리되지 않는 상태를 의미.
- 영속성 컨텍스트를 종료하거나 영속성 컨텍스트를 분리하면 해당 엔티티는 준영속 상태가 된다.

**▪️ 엔티티 생명주기 요약**

1. 비영속 (Transient): 처음 생성된 엔티티, 영속성 컨텍스트에 저장되지 않음.
2. 영속 (Persistent): `em.persist()`를 통해 영속성 컨텍스트가 관리하는 상태.
3. 준영속 (Detached): 영속 상태였던 엔티티가 영속성 컨텍스트에서 분리된 상태.
4. 삭제 (Removed): 영속 상태에서 `em.remove()`를 통해 삭제된 상태.

### 1) 변경 감지 (Dirty Checking)

변경 감지는 **영속 상태의 엔티티**에서만 동작하는 메커니즘

(JPA는 **영속 상태의 엔티티**를 트랜잭션 커밋 시점에 비교해서 변경된 부분을 자동으로 **UPDATE 쿼리**로 반영해 준다)

```java
@Transactional
void update(Item itemParam) { //itemParam: 파리미터로 넘어온 준영속 상태의 엔티티
Item findItem = em.find(Item.class, itemParam.getId()); //같은 엔티티를 조회한다.
findItem.setPrice(itemParam.getPrice()); //데이터를 수정한다.
}
```

1. 영속성 컨텍스트에서 엔티티를 다시 조회 `em.find()`→ 영속 상태로 변환.
2. 데이터 수정 → 변경 감지 발생.
3. 트랜잭션 커밋 → UPDATE SQL 자동 실행.

### 2) 병합 (Merge)

준영속 상태의 엔티티를 **영속 상태로 변경**할 때 사용하는 기능

```java
@Transactional
void update(Item itemParam) { //itemParam: 파리미터로 넘어온 준영속 상태의 엔티티
Item mergeItem = em.merge(itemParam);
}
```

1. 준영속 엔티티를 `em.merge()` 메서드에 넘겨주면 JPA가 처리 시작.
2. JPA는 **같은 식별자(ID)**를 가진 영속 상태의 엔티티를 조회(조회된 영속 엔티티가 없으면 새로 만들어서 관리)
3. 준영속 엔티티의 값을 영속 엔티티에 복사.
4. 병합된 영속 엔티티가 반환됨.
5. 트랜잭션 커밋 시점에 변경 사항이 감지되고 UPDATE SQL 실행.

| 항목 | **변경 감지 (Dirty Checking)** | **병합 (Merge)** |
| --- | --- | --- |
| **대상 상태** | 영속 상태의 엔티티 | 준영속 상태의 엔티티 |
| **수행 과정** | 영속 엔티티를 수정하면 변경 감지 발생 | 준영속 엔티티를 영속 상태로 병합 |
| **결과** | 같은 영속 엔티티를 그대로 사용 | 새로운 영속 엔티티를 반환 |
| **필드 처리** | 변경된 필드만 반영 | 모든 필드를 병합 |

✅ **모든 필드를 병합한다?** `merge()` 메서드를 호출하면 준영속 엔티티의 모든 필드 값이 영속 엔티티에 복사된다는 뜻. 이때 변경된 필드만 업데이트하는 것이 아니라 준영속 엔티티에 있는 모든 필드 값이 영속 엔티티에 반영됨. → 따라서 null인 필드도 복사될 수 있음

⇒ 결론

✅ 변경 감지를 사용할 것

✅ setter 없이 entity에서 바로 추적할 수 있는 method 만들기(추적 시 편하다)

- **인텔리제이 단축키**
    - `Command` + `E` : Recent Files" 창이 열려서 최근에 열었던 파일 목록을 보여줌.
    - `Option` + `Shift` + 마우스 드래그 : 여러 줄의 특정 컬럼(세로 영역)을 선택 가능.
    - `Command` 키를 두 번 연속으로 누르기 : Search Everywhere가 열림

noneNull과의 차이
